use diesel::update;
use diesel::prelude::*;

use tauri::State;

use crate::home_db::DatabaseState;

use std::cmp::max;
use tauri;
use chrono::{ 
  DateTime,
  Duration,
  prelude::*,
};

/*
 * Algo helpers
 */

pub fn get_num_boxes(days_to_go: i32, study_intensity: i32, num_reset: i32) -> i32 {
  let t = days_to_go;
  // bins generated by recursive equation x_n = x_{n-1} + 2^n + 1 
  // applied 5 times to (2, 6)
  let bins = vec![
        (0, 1), (2, 6), (7, 15), (16, 32), (33, 65), (66, 130), (131, 259)];
  let mut i = 0;
    let mut found_bin = false;
  for (a, b) in bins {
    if a <= t && t <= b {
            found_bin = true;
      break;
    }
    i += 1;
  }
  assert!(found_bin, "deadline must be between 0 and 259 days in the future");
  let mut num_boxes = 2 + i;

  // discount num_boxes based on study_intensity and num_reset
  num_boxes = max(2, num_boxes - (2 - study_intensity));
  num_boxes = max(2, num_boxes - num_reset);

  num_boxes
}

/**
 * Returns number of days until the given datetime, counting `new_day_time` as 
 * the time marking transition between days. Returns -1 if now is past the given 
 * datetime.
 * 
 * Args:
 *   datetime: date of the deadline in rfc3339 format
 *   new_day_time: hour (0-24) at which one day switches to the next
 *   test_day_time: hour `h` (0-24) such that if the test is after hour h 
 *                       then the test date is counted 
 */
pub fn days_until_deadline(
    datetime: DateTime<FixedOffset>,
    new_day_time: i64,
    test_day_time: i64
    ) -> i64 {
    // mark of new day: 2am
    // mark that deadline day is day 0: dl >= 2pm
    let mut day_bins: Vec<DateTime<FixedOffset>> = Vec::new();

    let mut inter = Local::now().with_timezone(&datetime.timezone());

    // get next time is at 2am
    inter = get_next_datetime_at_time(inter, new_day_time);
    
    // build up day_bins with datetimes at 2am on consecutive days
    while inter.timestamp() < datetime.timestamp() {
      day_bins.push(inter.clone());
      inter = get_next_datetime_at_time(inter, new_day_time);
    }


    if day_bins.len() == 0 {
      // on exam day
      if Local::now().timestamp() < datetime.timestamp() {
        return 0;
      }
      // past exam
      return -1;
    }

    // get deadline time in DateTime<Local>
    let dl_time = day_bins.last().unwrap().checked_add_signed(
      Duration::seconds((test_day_time - new_day_time) * 60 * 60)).unwrap();

    // time before test time does not count as a new day if it is before 2pm
    if datetime.hour() < test_day_time as u32 {
      day_bins.pop();
    }

    day_bins.push(dl_time);
    
    let now = Local::now().timestamp();

    for i in 0..day_bins.len() {
      if now < day_bins[i].timestamp() {
        let days = day_bins.len() - 1 - i;
        return days as i64;
      }
    }
    panic!("no day bins found")
}

fn get_next_datetime_at_time(dt: DateTime<FixedOffset>, time: i64) -> DateTime<FixedOffset> {
  // get time at 2am ahead of now
  let h = dt.hour() as i64;
  let m = dt.minute() as i64;
  let s = dt.second() as i64;
  let h_until_2am;
  if h < 2 {
      h_until_2am = time - h;
  } else {
      h_until_2am = 24 + time - h;
  }

  let thresh_ts = dt.checked_add_signed(
    Duration::seconds(h_until_2am as i64 * 60 * 60 - m * 60 - s)).unwrap();
  thresh_ts
}

#[tauri::command]
pub fn get_is_anki_frontend(state: State<DatabaseState>, deadline_id: i32) -> bool {
  let conn= &mut *state.conn.lock().unwrap();
  use crate::schema::deadlines;
    deadlines::table
        .find(deadline_id)
        .select(deadlines::is_anki)
        .first::<bool>(conn)
        .expect("failed to get is_anki")
}

pub fn get_is_anki(conn: &mut SqliteConnection, deadline_id: i32) -> bool {
  use crate::schema::deadlines;
    deadlines::table
        .find(deadline_id)
        .select(deadlines::is_anki)
        .first::<bool>(conn)
        .expect("failed to get is_anki")
}

/**
 * Count days in past where quota is not fulfilled, add unfilfilled progressions
 * to today's quota, and redistribute quotas to even out study cost over days
 */
#[derive(Debug)]
pub struct QuotaTempRecord {
  pub dtg: i32, // days_to_go
  pub nq: i32,  // new_quota
  pub rq: i32,  // review_quota
  pub nqp: i32, // new_quota_practiced
  pub rqp: i32  // review_quota_practiced
}

pub fn handle_missed_days(conn: &mut SqliteConnection, deck_id: i32, days_to_go: &i32) {
    use crate::schema::quotas;
    let mut curr_idx = *days_to_go as usize;

    // read quotas 
    let quota_tuples = quotas::table
        .filter(quotas::id.eq(deck_id).and(quotas::days_to_go.lt(days_to_go + 1)))
        .select((quotas::days_to_go, quotas::new_assigned, quotas::review_assigned, quotas::review_practiced, quotas::new_practiced))
        .get_results::<(i32, i32, i32, i32, i32)>(conn)
        .expect("failed to get quotas");

    let mut quotas = Vec::new();
    for t in quota_tuples {
        quotas.push(
            QuotaTempRecord { dtg: t.0, nq: t.1, rq: t.2, nqp: t.3, rqp: t.4 }
        )
    }

    // if deadline has passed, act as if last day
    if (curr_idx as i32) < 0 {
        curr_idx = 0;
    }

    // return if no previous days
    if curr_idx + 1 == quotas.len() {
        return;
    }

    let (mut nq_missed, mut rq_missed) = (0, 0);
    for i in (curr_idx + 1)..quotas.len() {
        // count up number of progressions missed in the past
        nq_missed += quotas[i].nq - quotas[i].nqp;
        rq_missed += quotas[i].rq - quotas[i].rqp;

        // set past quota to the amount that was practiced
        quotas[i].nq = quotas[i].nqp;
        quotas[i].rq = quotas[i].rqp;
    }

    // return if no missed days
    if nq_missed == 0 && rq_missed == 0 {
        return;
    }

    // add missed cards to today if it is the last day
    if curr_idx == 0 {
        quotas[curr_idx].nq += nq_missed;
        quotas[curr_idx].rq += rq_missed;
        return;
    }



    // add missed cards to days up to and including current day, without deadline day
    let num_days = curr_idx as i32;
    let new_per_day = nq_missed / num_days;
    let new_rmdr = nq_missed - new_per_day * num_days;
    let review_per_day = rq_missed / num_days;
    let review_rmdr = rq_missed - review_per_day * num_days;

    // distribute cards up to and including current day, skipping day of exam
    for dtg in 1..=curr_idx {

        // distribute burden for missed quotas on past days
        quotas[dtg].nq += new_per_day;
        quotas[dtg].rq += review_per_day;

        // add remainder to proper days (semi-arbirarily chosen)
        if dtg == 1 {
            quotas[dtg].rq += review_rmdr;
        } else if dtg == curr_idx {
            quotas[dtg].nq += new_rmdr;
        }

    }

    // update quotas database with new quotas
    for quota in quotas {
        update(quotas::table)
            .filter(quotas::id.eq(deck_id).and(quotas::days_to_go.eq(quota.dtg)))
            .set((quotas::new_assigned.eq(quota.nq), quotas::review_assigned.eq(quota.rq)))
            .execute(conn)
            .expect("failed to update quota");
    }

}