
use tauri;
use std::{ 
    sync::{
      Mutex, 
      Arc
    },
    io::{BufReader, BufRead},
    path::{ PathBuf },
    collections::hash_map::DefaultHasher,
    hash::{ Hash, Hasher },
    // fmt::Debug,
    fs::OpenOptions
};
use serde::{
    Serialize, 
    Deserialize
};
use chrono::{ 
  DateTime,
  prelude::*,
};

  
  
/*
 * Structs
 */

// want ReviewSession to be Vec<LeitnerBoxSystem>
#[allow(dead_code)]
pub struct ReviewSessionState {
  pub cards_arc: Arc<Mutex<Option<LeitnerBoxSystem>>>,
}
#[allow(dead_code)]
pub struct LeitnerBoxSystem {
  pub deck_name: String
}
// Path to folder with app data
#[allow(dead_code)]
pub struct AppDataDirState{
  pub path: Option<PathBuf>
}

// info about a deck
#[derive(Serialize, Deserialize)]
struct DeckEntry {
  pub id: usize,
  pub name: String,
  pub deadline_string: String,
}

/*
 * Date Helpers
 */

 pub fn get_days_to_go(deck_path: &PathBuf) -> i32 {
    let deadline = read_deadline(&deck_path)
      .expect("deadline not found in config");
    
    let datetime = deadline_to_datetime(deadline);
    let days_to_go = days_until_datetime(datetime) as i32;
    days_to_go 
 }

pub fn deadline_to_datetime(deadline_string: String) -> DateTime<FixedOffset> {
    if deadline_string.chars().count() == 25 {
        return DateTime::parse_from_rfc3339(&deadline_string)
            .expect("failed to parse datetime in the rfc3339 format");
    } else {
        panic!(
            "deadline string must have form or rfc3339 but got: {}", 
            deadline_string);
    }
}

pub fn days_until_datetime(datetime: DateTime<FixedOffset>) -> i64 {
    datetime.signed_duration_since(Local::now()).num_days()
}

 // id of a card is hash of its deck name, front, and back fields concatenated
#[tauri::command] 
pub fn calculate_hash(deck_name: String, front: String, back: String) -> u64 {
    let t = deck_name + &front + &back;
    let mut s = DefaultHasher::new();
    t.hash(&mut s);
    s.finish()
}





/*
 * fs helpers 
 */

// given path to deck dir, returns value of field_name if found (otherwise None)
pub fn read_num_boxes(deck_path: &PathBuf) -> Option<i32> {
    
    let config_path = deck_path.join("config.toml");
    if !config_path.is_file() {
      return None;
    }

    let file = OpenOptions::new()
        .read(true)
        .open(config_path)
        .expect("failed to open deck cfg");
    let file = BufReader::new(file);

    for line in file.lines() {
        let line = line.expect("failed to read line from cfg");
        let mut it = line.split("=");
        let name = it.next().unwrap().trim();
        if name == "num_boxes" {
            let data = it.next()
                .expect("trying to retrieve empty field").trim();
            let data = data.parse::<i32>().expect("failed to extract value");
            return Some(data);
        }
    }
    None
}

pub fn read_deadline(deck_path: &PathBuf) -> Option<String> {

    let config_path = deck_path.join("config.toml");
    if !config_path.is_file() {
      return None;
    }

    let file = OpenOptions::new()
        .read(true)
        .open(config_path)
        .expect("failed to open deck cfg");
    let file = BufReader::new(file);

    for line in file.lines() {
        let line = line.expect("failed to read line from cfg");
        let mut it = line.split("=");
        let name = it.next().unwrap().trim();
        if name == "deadline" {
            let data = it.next()
                .expect("trying to retrieve empty field").trim();
            return Some(data.to_string());
        }
    }
    None
}



/*
 * Algo helpers
 */

#[allow(dead_code)]
pub fn get_num_boxes(days_to_go: i64) -> i32 {
  let t = days_to_go as i32;
  // bins generated by recursive equation x_n = x_{n-1} + 2^n + 1 
  // applied 5 times to (2, 6)
let bins = vec![
      (0, 1), (2, 6), (7, 15), (16, 32), (33, 65), (66, 130), (131, 259)];
let mut i = 0;
  let mut found_bin = false;
for (a, b) in bins {
  if a <= t && t <= b {
          found_bin = true;
    break;
  }
  i += 1;
}
  assert!(found_bin, "deadline must be between 0 and 259 days in the future");
let num_boxes = 2 + i;
num_boxes
}